ContactsRank
============
不足：未考虑联系人有多个电话号码的情况、删除联系人后的情况

编写过程：
一开始的时候，为短信记录、通话记录、联系人分别建立了model类

在获取短信信息的时候，由于mmssms.db中只有发送或接受短信的对方的电话号码，不能判断此短信是否来自通讯录好友，因此需要从contacts2.db中查询是否存在此电话号的联系人，若不存在，则舍去。

在获取通话记录时，若通话时此通话人存在联系人列表中，则calls表中name一栏不为空。

考虑每次获取的都是新的短信记录、通话记录，设置了一个target,每次打开程序后，target存储的是上次打开程序时的epoch time（初始化时为零，这样就可以第一次获取全部信息），在获取新信息后，更新此target为当前时间。

考虑新增联系人，由于存储联系人信息的表中未存储添加联系人时的时间，因此每次启动程序时首先都需要检测是否有新增联系人，若有联系人不存在我们程序的rank表中，则添加，并且初始化分数。

考虑整合新信息，为了方便起见，首先把新信息插入程序的数据库中，再提取此月的总数据，算分，更新到rank表中(若首次打开，或者上次打开应用时不在此月，则先算总分，再算月分)。

在编写时，由于粗心，经常遇到nullpointerexception。

由于sms和call存取数据库时很相似，相互copy，经常忘把query函数中的参数修改，导致结果就是有新短信时，打开程序，联系人分数不增加，有新通话时，联系人分数是正常通话得分的2倍，粗心导致整个下午找不到错。。。

程序在运行在有很多短信和通话记录的手机时，经常崩溃，后来用真实手机测试的时候才发现遇到了cannot dup fd=1023, size=1048576, err=0 (Too many open files) 这个错误，找其原因，是每个短信和通话记录都会查询手机通讯录，导致内存资源没有被释放。于是在首次查询的时候，我将通讯录存到ArrayList<Contact>中，之后每次需要查询都去从ArrayList<Contact>查询，节省了很多空间。

在每次获取新信息的时候，由于每次都获取了所有联系人的分数，因此去掉那些月分数为零的（跨月时去掉月分数和总分数都为零）的好友后，再更新rank表。

当联系人的电话号不止一个时，发现评分出现了错误，分析整个过程，发现在获取通讯录的时候，若某联系人有两个电话号，则此联系人有两条记录，每个记录对应一个电话号码，但是两条记录的cid和name是相同的，因此，在根据通讯录来判断一个电话号码是不是存在于通讯录的时候，需要获取全部的通信录信息，而在根据通讯录进行评分的时候，则ArrayList<Contact>中每个联系人必须只存在一个，因此在向ArrayList<Contact>添加新child的时候，需判断ArrayList<Contact>中是否存在此联系人，若不存在，则添加。


这是这学期唯一一次写稍微长点的程序...